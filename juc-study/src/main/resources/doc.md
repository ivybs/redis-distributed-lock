## Thread
Thread类实现了Runnable接口


## Runnable\Callable\Future 三个接口
1.Runnable
run(): 新开一个线程

2.Callable
call():新开一个线程，并有返回值；
相当于有返回值，且若线程执行任务出现异常，也会将异常抛出给主线程

3.Future
当方法执行完成后，异步的获取线程执行结果
get()阻塞\isDone()轮询


## FutureTask
实现了 Runnable\Future接口，并且构造函数可以传入Callable接口的实现类
也就是说 FutureTask可以实现： 多线程（Runnable接口提供）、异步执行任务（Future接口提供）、有返回值（Callable接口提供）

缺点：get() 阻塞 ，线程可能还没执行完，只要调用get那么就会立马去找对应的线程，直到对应的线程返回值，才会继续走主线程，
        get()可以传入超时时间，如果超时就会抛出超时的异常
    isDone() 轮询：为了不让get阻塞，可以用轮询isDone方法，判断是否执行完成， 一直轮询查询线程是否执行完成，一直轮询会导致cpu空转
     
想要的新功能：回调通知、创建异步任务、多个任务前后依赖关系、选计算速度最快

## CompletableFuture  实现了Future接口和CompletionStage接口 Java8才有的
提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方

优点：1.异步任务结束时，会自动调用whenComplete方法
     2.主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行 
     3.异步任务出错时，会自动回调exceptionally方法



## CompletableFuture实战
1需求说明
1.1同一款产品，同时搜索出同款产品在各大电商平台的售价;
1.2同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少
2 输出返回:
出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String>
《mysql》 in jd price is 88.05
《mysql》 in dangdang price is 86.11
《mysql》in taobao price is 90.43
3解决方案，比对同一个商品在各个平台上的价格，要求获得一个清单列表，
① stepbystep，按部就班，查完京东查淘宝，查完淘宝查天猫.，
② all in 万箭齐发，一口气多线程异步任务同时查询。。。。。




## 8锁
8锁案网说明:
1 标准访问ab两个线程、请问先打印邮件还是短信
2.sendEmail万法中加入暂停3秒钟，请问先打印邮件还是短信
3.添加一个普通的hello方法，请问先打印邮件还是hello
4.有两部手机，请问先打印邮件还是短信
5.有两个静态同步方法，有1部手机，请问先打印邮件还是短信
6.有两个静态国步方法，有2部手机，请问先打印邮件还是短信
7.有1个静态同步方法，有1个普通同步方法,有1部手机，请问先打印邮件还是短信
8.有1个静态同步方法，有1个普通同步方法,有2部手机，请问先打印邮件还是短信



1-2：1个对象里面如果有多个synchronized方法，某一个时刻内，只一个线程去调用其中的一个synchronized方法了，
其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法率锁的是当前对象this，
被领定后，其它的球程都不能进入到当前对象的其它的synchronized方法
3-4加个普通方法后发现和同步锁无关换成两个对象后，不是同一把锁了，持况立刻变化。
5-6 都换成静态同步方法后，情况又变化，三种 synchronized 锁的内容自一些差别:
对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部手机,所有的普通同步方法用的都是同一把锁一>实例对象本身,
对于静态同步方法，锁的是当前类的class对象，如Phone.class唯一的一个板
对于同步方法块，锁的是synchronized 括号内的对象
7-8：当一个线程试图访间同步代码时它首先必须得到锁，正常退出或抛出异常时必须释放锁
所有的普通同步方法用的都是同一把锁一实例对象本身，就是new出来的具体实例对象本身,本类this也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁
所有的静态同步方法用的也是同一把锁一类对象本身，就是我们说过的唯一板cLass具体实例对象this和唯一板cLass，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的
但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放后才获取锁。

































